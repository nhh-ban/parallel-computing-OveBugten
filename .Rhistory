return(test_result$p.value)
}
for(i in 1:nrow(df2.4)){
N = df2.4$N[i]
M = df2.4$M[i]
df2.4$share_reject[i] = MTweedieTests(M, N, 0.05)
df2.4$normal_reject[i] = normal_sample_rejects(N, 10000)
}
normal_sample_rejects <- function(N, mu) {
sample <- rnorm(N, mu)
test_result <- t.test(sample, mu)
return(test_result$p.value)
}
for(i in 1:nrow(df2.4)){
N = df2.4$N[i]
M = df2.4$M[i]
df2.4$share_reject[i] = MTweedieTests(M, N, 0.05)
df2.4$normal_reject[i] = normal_sample_rejects(N, 10000)
}
df2.4
?rnorm
normal_sample_rejects(10,10)
normal_sample_rejects(1000,10000)
normal_sample_rejects(10,10)
N2.4 = c(10,50,100,1000,5000)
M2.4 = c(100, 100, 100, 100, 100)
share_reject2.4 = c(NA, NA, NA, NA, NA)
normal_2.4 = c(NA, NA, NA, NA, NA)
library(tibble)
df2.4 <- tibble(N = N2.4,
M = M2.4,
share_reject = share_reject2.4,
normal_reject = normal_2.4)
# Function to simulate data & run a t-test
simTest <- function(N, distribution = "tweedie", mu = 10000, phi = 1000, power = 1.9) {
if (distribution == "tweedie") {
sample <- rtweedie(N, mu = mu, phi = phi, power = power)
} else if (distribution == "normal") {
sample <- rnorm(N, mean = mu)
} else {
stop("Unsupported distribution type.")
}
test_result <- t.test(sample, mu = mu)
return(test_result$p.value)
}
# Function to perform multiple tests
MTests <- function(M, N, alpha = 0.05, distribution, mu = 10000, phi = 1000, power = 1.9) {
p_values <- replicate(M, simTest(N, distribution, mu, phi, power))
proportion <- sum(p_values < alpha) / M
return(proportion)
}
N2.4 = c(10,50,100,1000,5000)
M2.4 = c(100, 100, 100, 100, 100)
share_reject2.4 = c(NA, NA, NA, NA, NA)
normal_2.4 = c(NA, NA, NA, NA, NA)
library(tibble)
df2.4 <- tibble(N = N2.4,
M = M2.4,
share_reject = share_reject2.4,
normal_reject = normal_2.4)
# Function to simulate data & run a t-test
simTest <- function(N, distribution = "tweedie", mu = 10000, phi = 1000, power = 1.9) {
if (distribution == "tweedie") {
sample <- rtweedie(N, mu = mu, phi = phi, power = power)
} else if (distribution == "normal") {
sample <- rnorm(N, mean = mu)
} else {
stop("Unsupported distribution type.")
}
test_result <- t.test(sample, mu = mu)
return(test_result$p.value)
}
# Function to perform multiple tests
MTests <- function(M, N, alpha = 0.05, distribution, mu = 10000, phi = 1000, power = 1.9) {
p_values <- replicate(M, simTest(N, distribution, mu, phi, power))
proportion <- sum(p_values < alpha) / M
return(proportion)
}
for(i in 1:nrow(df2.4)){
N = df2.4$N[i]
M = df2.4$M[i]
df2.4$share_reject[i] = MTests(df2.4$M[i], df$N[i], 0.05, "tweedie")
df2.4$normal_reject[i] = MTests(df2.4$M[i], df$N[i], 0.05, "normal")
}
for(i in 1:nrow(df2.4)){
N = df2.4$N[i]
M = df2.4$M[i]
df2.4$share_reject[i] = MTests(M, N, 0.05, "tweedie")
df2.4$normal_reject[i] = MTests(M, N, 0.05, "normal")
}
df2.4
N2.4 = c(10,50,100,1000,5000, 10000)
M2.4 = c(100, 100, 100, 100, 100, 100)
share_reject2.4 = c(NA, NA, NA, NA, NA, NA)
normal_2.4 = c(NA, NA, NA, NA, NA, NA)
library(tibble)
df2.4 <- tibble(N = N2.4,
M = M2.4,
share_reject = share_reject2.4,
normal_reject = normal_2.4)
# Function to simulate data & run a t-test
simTest <- function(N, distribution = "tweedie", mu = 10000, phi = 1000, power = 1.9) {
if (distribution == "tweedie") {
sample <- rtweedie(N, mu = mu, phi = phi, power = power)
} else if (distribution == "normal") {
sample <- rnorm(N, mean = mu)
} else {
stop("Unsupported distribution type.")
}
test_result <- t.test(sample, mu = mu)
return(test_result$p.value)
}
# Function to perform multiple tests
MTests <- function(M, N, alpha = 0.05, distribution, mu = 10000, phi = 1000, power = 1.9) {
p_values <- replicate(M, simTest(N, distribution, mu, phi, power))
proportion <- sum(p_values < alpha) / M
return(proportion)
}
for(i in 1:nrow(df2.4)){
N = df2.4$N[i]
M = df2.4$M[i]
df2.4$share_reject[i] = MTests(M, N, 0.05, "tweedie")
df2.4$normal_reject[i] = MTests(M, N, 0.05, "normal")
}
df2.4
df2.3 %>%
ggplot(aes(x = N, y = share_reject)) +
geom_point() +
geom_line() +
scale_x_log10(breaks = df$N) +
labs(title = "Share of Rejections vs Sample Size") +
theme_minimal()
df2.4 %>%
ggplot(aes(x = N, y = share_reject, y = normal_reject)) +
geom_point() +
geom_line() +
scale_x_log10(breaks = df$N) +
labs(title = "Share of Rejections vs N") +
theme_minimal()
df2.4 %>%
ggplot(aes(x = N, y = share_reject, normal_reject)) +
geom_point() +
geom_line() +
scale_x_log10(breaks = df$N) +
labs(title = "Share of Rejections vs N") +
theme_minimal()
df2.4 %>%
ggplot(aes(x = N)) +
geom_point() +
geom_line(aes(y = share_reject), linetype = "dashed") +
geom_line(aes(y = normal_reject), linetype = "solid") +
scale_x_log10(breaks = df$N) +
labs(title = "Share of Rejections vs N") +
theme_minimal()
df2.4 %>%
ggplot(aes(x = N, y = normal_reject)) +
geom_point() +
geom_line(aes(y = share_reject), linetype = "dashed") +
geom_line(aes(y = normal_reject), linetype = "solid") +
scale_x_log10(breaks = df$N) +
labs(title = "Share of Rejections vs N") +
theme_minimal()
library(purrr)
library(tidyverse)
df <-
tibble(
a = rnorm(10),
b = rnorm(10),
c = rnorm(10),
d = rnorm(10),
e = rnorm(10)
)
median(df$a)
median(df$b)
median(df$c)
median(df$d)
median(df$e)
col_summary <- function(df, fun) {
out <- vector("double", length(df))
for (i in seq_along(df)) {
out[i] <- fun(df[[i]])
}
out
}
col_summary(df, mean)
col_summary(df, median)
col_summary(df, sd)
map(df, mean)
df |>
map(mean, trim=.1) |>
bind_cols()
df |>
map(
{
\(x) mean(x) / sd(x)
}
) |>
bind_cols()
mtcars |>
split( ~ cyl) |>
map({
\(x)lm(mpg ~ wt, data = x)
}) |>
map(summary) |>
map({
\(x) x$r.squared
}) |>
bind_cols()
mtcars |>
split( ~ cyl) |>
map({
\(x)lm(mpg ~ wt, data = x)
}) |>
map(summary) |>
map({
\(x) x$r.squared
}) |>
bind_cols()
x <- list(1, 10, "a")
y <- x |> map(log)
y |>
map("error") |>
map(is_null)
y <- x |> map(safely(log))
y |>
map("error") |>
map(is_null)
x |> map(possibly(log, NA_real_))
mu <- list(-10000, 0, 10000)
sigma <- list(1, 5, 10)
map2(mu,sigma,rnorm,n=5)
list(mean = mu,
sd = sigma,
n = n) |>
pmap(rnorm)
mu    <- list(-10000, 0, 100)
sigma <- list(     1, 5,  10)
n     <- list(     1, 10, 25)
list(mean = mu,
sd = sigma,
n = n) |>
pmap(rnorm)
install.packages("httr")
install.packages("jsonlite")
install.packages("DescTools")
installed.packages("rlang")
install.packages("rlang")
install.packages("rlang")
#Getting some data
library(httr)
library(jsonlite)
library(DescTools)
library(ggplot2)
library(tidyverse)
library(magrittr)
library(rlang)
library(lubridate)
library(anytime)
install.packages("anytime")
GQL <- function(query,
...,
.token = NULL,
.variables = NULL,
.operationName = NULL,
.url = url) {
pbody <-
list(query = query,
variables = .variables,
operationName = .operationName)
if (is.null(.token)) {
res <- POST(.url, body = pbody, encode = "json", ...)
} else {
auth_header <- paste("bearer", .token)
res <-
POST(
.url,
body = pbody,
encode = "json",
add_headers(Authorization = auth_header),
...
)
}
res <- content(res, as = "parsed", encoding = "UTF-8")
if (!is.null(res$errors)) {
warning(toJSON(res$errors))
}
res$data
}
# The URL we will use is stored below:
url <- "https://www.vegvesen.no/trafikkdata/api/"
# Let's figure out which sensor stations that are operable.
# The query below extracts all the stations, with a date for
# when the station was in operation as well as a long/latitude.
qry <-
'
{
trafficRegistrationPoints {
id
name
latestData {
volumeByDay
}
location {
coordinates {
latLon {
lat
lon
}
}
}
}
}
'
# Allright - let's try submitting the query:
stations <-GQL(qry)
length(stations)
length(stations[[1]])
stations[[1]][[1]]
stations[[1]][[1]] |>
as_tibble()
setwd("C:/H23/RTDS/GitOWB/parallel-computing-OveBugten/parallel-computing-OveBugten")
library(tictoc)
library(doParallel)
library(foreach)
install.packages(foreach)
install.packages(iterators)
install.packages("parallel")
install.packages("parallel")
library(tictoc)
library(foreach)
library(iterators)
library(parallel)
library(doParallel)
library(tweedie)
library(ggplot2)
library(tidyverse)
tic.clearlog()
tic("Original Solution")
source("scripts/hw4_solution1.r")
toc()
tic("Parallel loop 29-35")
source("scripts/hw4_solution2.r")
tic("Rewritten MTweedietests")
source("scripts/hw4_solution3.r")
toc()
tic("Rewritten MTweedietests")
source("scripts/hw4_solution3.r")
toc()
install.packages("furr")
install.packages("furrr")
tic("Rewritten MTweedietests")
source("scripts/hw4_solution3.r")
toc()
tic("Parallel loop 29-35")
source("scripts/hw4_solution2.r")
tic.clearlog()
tic("Original Solution")
source("scripts/hw4_solution1.r")
toc()
tic("Rewritten MTweedietests")
source("scripts/hw4_solution3.r")
toc()
printTicTocLog() %>%
knitr::kable()
tictoc::printTicTocLog()
TicToc::printTicTocLog()
install.packages("tictoc")
install.packages("tictoc")
tic("Parallel loop 29-35")
source("scripts/hw4_solution2.r")
tweedie::rtweedie()
# Assignment 1:
library(tweedie)
library(ggplot2)
library(tictoc)
tweedie::rtweedie()
simTweedieTest <-
function(N){
t.test(
rtweedie(N, mu=10000, phi=100, power=1.9),
mu=10000
)$p.value
}
# Assignment 2:
MTweedieTests <-
function(N,M,sig){
sum(replicate(M,simTweedieTest(N)) < sig)/M
}
# Assignment 3:
df <-
expand.grid(
N = c(10,100,1000,5000, 10000),
M = 1000,
share_reject = NA)
#Rewritten lines 29-35
# Register the number of available cores for parallel processing
# Determine the maximum number of cores you'd like to use
maxcores <- 8
Cores <- min(parallel::detectCores(), maxcores)
# Instantiate the cores:
cl <- makeCluster(Cores)
# Register the cluster for parallel processing
registerDoParallel(cl)
results <-
foreach(i=1:nrow(df), .combine='c') %dopar%
{
MTweedieTests(N=df$N[i], M=df$M[i], sig=.05)
}
# Stop the cluster after computation
stopCluster(cl)
results <-
foreach(i=1:nrow(df), .combine='c') %dopar%
{
MTweedieTests(N=df$N[i], M=df$M[i], sig=.05)
}
#Rewritten lines 29-35
# Register the number of available cores for parallel processing
# Determine the maximum number of cores you'd like to use
maxcores <- 8
Cores <- min(parallel::detectCores(), maxcores)
# Instantiate the cores:
cl <- makeCluster(Cores)
# Register the cluster for parallel processing
registerDoParallel(cl)
results <-
foreach(i=1:nrow(df), .combine='c') %dopar%
{
MTweedieTests(N=df$N[i], M=df$M[i], sig=.05)
}
results <- foreach(i=1:nrow(df), .combine = "c") %dopar%
{MTweedieTests(N=df$N[i], M=df$M[i], sig=.05)}
results <- foreach(i=1:nrow(df), .combine = "c") %dopar%
MTweedieTests(N=df$N[i], M=df$M[i], sig=.05)
tweedie::rtweedie()
update.packages(tweedie)
update.packages("tweedie")
tweedie::rtweedie()
# Assignment 1:
library(tweedie)
library(ggplot2)
library(tictoc)
simTweedieTest <-
function(N){
t.test(
rtweedie(N, mu=10000, phi=100, power=1.9),
mu=10000
)$p.value
}
# Assignment 2:
MTweedieTests <-
function(N,M,sig){
sum(replicate(M,simTweedieTest(N)) < sig)/M
}
# Assignment 3:
df <-
expand.grid(
N = c(10,100,1000,5000, 10000),
M = 1000,
share_reject = NA)
#Rewritten lines 29-35
# Register the number of available cores for parallel processing
# Determine the maximum number of cores you'd like to use
maxcores <- 8
Cores <- min(parallel::detectCores(), maxcores)
# Instantiate the cores:
cl <- makeCluster(Cores)
# Register the cluster for parallel processing
registerDoParallel(cl)
results <- foreach(i=1:nrow(df), .combine = "c") %dopar%
{MTweedieTests(N=df$N[i], M=df$M[i], sig=.05)}
#Rewritten lines 29-35
# Register the number of available cores for parallel processing
# Determine the maximum number of cores you'd like to use
maxcores <- 8
Cores <- min(parallel::detectCores(), maxcores)
# Instantiate the cores:
cl <- makeCluster(Cores)
# Register the cluster for parallel processing
registerDoParallel(cl)
results <- foreach(i=1:nrow(df), .combine = "c", .packages = c('tweedie')) %dopar%
{MTweedieTests(N=df$N[i], M=df$M[i], sig=.05)}
# Assign results to df column
df$share_reject <- results
# Stop the cluster after computation
stopCluster(cl)
library(tictoc)
library(foreach)
library(iterators)
library(parallel)
library(doParallel)
library(tweedie)
library(ggplot2)
library(tidyverse)
library(furrr)
tic.clearlog()
tic("Original Solution")
source("scripts/hw4_solution1.r")
toc()
tic("Parallel loop 29-35")
source("scripts/hw4_solution2.r")
toc()
tic("Rewritten MTweedietests")
source("scripts/hw4_solution3.r")
toc()
tic("Rewritten MTweedietests")
source("scripts/hw4_solution3.r")
toc()
printTicTocLog() %>%
knitr::kable()
tic("Rewritten MTweedietests")
source("scripts/hw4_solution3.r")
toc()
